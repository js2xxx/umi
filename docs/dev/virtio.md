# Virt IO 设备驱动程序

其中的VirtIO块设备的驱动程序调用的是[`virtio-drivers`](https://github.com/rcore-os/virtio-drivers/tree/new-netdev)中的`*_nb`（非阻塞）函数，然后通过中断通知来实现异步操作。VirtIO块设备中包含一个Virt队列，分为提交队列跟完成队列，类似Linux的io-uring实现。

驱动过程
  1. 提交：线程 A 提交任务给提交队列, 然后睡眠等待通知；
  2. 等待中断；
  3. 完成：
     1. 设备发出中断信号；
     2. 驱动设备维护线程 B 接受信号，将对应的请求操作结构体从提交队列移入结束队列，唤醒 A；
     3. A 检查结束队列中的最新任务是否和自己符合，若符合则将其删除，完成操作并返回。

## 块设备

块设备的驱动遵循最基本的过程，将上述驱动流程包装在一个大`Future`里，同时使用了一次性通道来传递缓冲区的所有权来保证读写任务取消不会泄露缓冲区。

## 网络设备

由于网络设备跟块设备接口的差异，我们将上述驱动流程拆分在`peek`,`buffer`,`consume`（即`transmit`和`receive`）三个接口函数中，接下来对发送和接收队列作不同的讲解：

### 发送队列

- `peek`：首先通过轮询完成已经完成的发送包（即上述流程的 3），清空发送队列的完成队列；然后在提交队列中预留一个位置作为`Token`返回；提交队列满则返回`None`；
- `buffer`：清零预先分配的缓冲区，在缓冲区头建立物理帧头，并返回后面用户数据区的可变引用；
- `transmit`：将该块缓冲区提交到请求队列（即上述流程的 1）。

### 接收队列

在设备初始化之后便将接收队列的请求队列塞满，让设备的接收队列开始工作（即上述流程的 1）。

- `peek`：同样清空接收队列的完成队列，返回可能的接收包对应的`Token`（即上述流程的 3）；
- `buffer`：返回该令牌对应的缓冲区用户数据的可变引用；
- `receive`：结束接收流程，将空出来的请求队列再次塞满（即上述流程的 1）。