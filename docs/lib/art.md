### `art`

该模块的名称是Async RunTime的缩写，即该模块实现了一个多核的异步执行器，参考了[Tokio](https://tokio.rs/)的实现。

实现的功能有：

- 任务窃取，即在一个工作队列没有任务时，会去其他工作队列偷一部分任务回来运行。
- 软抢占式调度：对于 IO 唤醒等特殊情况下被唤醒的任务，将其放在单独的`preempt_slot`中，在该工作队列调度时优先选择。

该异步执行器是与[`async-task`](https://docs.rs/async-task/latest/async_task/)合作实现的。由于软抢占式调度需要获取任务本身的内部信息，而之前版本的`async-task`并未提供访问这一信息的接口。因此徐启航同学向其提交了一个新的PR，目前已经被合并发布在4.4.0版本中。

#### 表示用户线程的生命周期

那么，如何处理用户代码和内核代码的切换呢？靠的是之前讲的`co-trap`。因为`co-trap`中内核与用户态之间是以有栈协程的方式进行切换的，我们可以很自然地建构出如下伪代码来表示一个用户线程在内核态的生命周期：

```rust
loop {
    // 切换到用户态，执行用户态代码，等待中断或异常。
    let result = yield_to_user(&mut some_trap_frame);
    //从用户态返回，处理导致返回的中断或异常。
    match handle_user(result, &mut some_trap_frame).await {
        // 视情况而定，如果一般系统调用成功，则继续返回用户态；
        Ok(()) => continue,
        // 如果调用了EXIT系统调用，或者发生了不可挽回的异常，则跳出循环，结束该线程。
        Err(err) => break err,
    }
}
```

可以看到，这种代码就像一个事件循环一般，有写过裸Win32程序的同学们应该有点熟悉。

这两个模块在功能上是正交的，完全可以将该执行器换成任意其他执行器也可以来完成功能的实现。